notation number-0 { ℕ.0 }
notation number-suc { ℕ.suc }

inductive =(A: Type, x: A): A → Type {
	refl: = A x x,
}

inductive ℕ: Type 0 {
	0: ℕ,
	suc: ℕ → ℕ,
}

inductive Vec(A: Type): ℕ → Type {
	nil: Vec A 0,
	cons: (n: ℕ, Vec A n, A) → Vec A (ℕ.suc n),
}

def Vec.prepend(A: Type, n: ℕ, v: Vec A n, a: A): Vec A (ℕ.suc n) {
	match v to [n v] Vec A (ℕ.suc n) {
		nil => Vec.cons A 0 (Vec.nil A) a,
		cons n' v' a' => Vec.cons A (ℕ.suc n') (rec v') a',
	}
}

// def Vec.prepend-elim(A: Type, n: ℕ, v: Vec A n, a: A): Vec A (ℕ.suc n) {
// 	Vec.elim A ([n: ℕ, v: Vec A n] Vec A (ℕ.suc n))
// 		(Vec.cons A 0 (Vec.nil A) a)
// 		([n': ℕ, v': Vec A n', a': A, v'_rec: Vec A (ℕ.suc n')]
// 		    Vec.cons A (ℕ.suc n') v'_rec a'
// 		)
// 		n v
// }

def just_1: Vec ℕ 1 {
	Vec.cons ℕ 0 (Vec.nil ℕ) 1
}

def just_2: Vec ℕ 1 {
	Vec.cons ℕ 0 (Vec.nil ℕ) 2
}

def just_1_2: Vec ℕ 2 {
	Vec.cons ℕ 1 just_1 2
}

def just_1_2=prepend_1_just_2: = (Vec ℕ 2) just_1_2 (Vec.prepend ℕ 1 just_2 1) {
	=.refl (Vec ℕ 2) just_1_2
}
