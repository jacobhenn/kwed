inductive =(A: Type, x: A): A → Type
{
	refl: = A x x,
}

// Function extensionality
axiom POINTWISE: (A B: Type, f g: A → B, (x: A) → (((= B) (f x)) (g x))) → = (A → B) f g;

def =.cong(A B: Type, f: A → B, x y: A, x=y: = A x y): = B (f x) (f y)
{
	=.elim A x ([y: A, x=y: = A x y] = B (f x) (f y)) (=.refl B (f x)) y x=y
}

def =.transport(A: Type, F: A → Type, x y: A, x=y: = A x y): (F x) → (F y)
{
	=.elim A x ([y: A, x=y: = A x y] (F x) → (F y)) ([z: F x] z) y x=y
}

def IsProp(A: Type): Type
{
	[x y: A] = A x y
}

inductive False: Type {}

def False.is_prop(x y: False): = False x y
{
	False.elim ([_: False] = False x y) x
}

def Not(A: Type): Type
{
	A → False
}

inductive Unit: Type
{
	0: Unit,
}

inductive Product(A: Type, F: A → Type): Type
{
	pair: (a: A, F a) → Product A F,
}

def ×(A B: Type): Type
{
	Product A ([_: A] B)
}

def Prop: Type
{
	Product Type ([A: Type] IsProp A)
}

inductive Sum(A B: Type): Type
{
	left: A → Sum A B,
	right: B → Sum A B,
}

// Law of the excluded middle
axiom DECIDE: (A: Type) → Sum A (Not A);

def Merely(A: Type): Type
{
	Not (Not A)
}

def Merely.from(A: Type, a: A): Merely A
{
	[¬A: Not A] ¬A a
}

def Merely.is_prop(A: Type, x y: Merely A): = (Merely A) x y
{
	POINTWISE (Not A) False x y ([¬A: Not A] False.is_prop (x ¬A) (y ¬A))
}

def Merely.ind(A B: Type, f: A → B, ma: Merely A): B
{
	Sum.elim A (Not A) ([Sum A (Not A)] B)
		([a: A] f a)
		([¬A: Not A] False.elim ([_: False] B) (ma ¬A))
		(DECIDE A)
}

def Merely.comp(A B: Type, f: A → B, a: A): = B (Merely.ind A B f (Merely.from A a)) (f a)
{
	
}

inductive ℕ: Type
{
	0: ℕ,
	suc: ℕ → ℕ,
}

def ℕ.1: ℕ { ℕ.suc ℕ.0 }
def ℕ.2: ℕ { ℕ.suc ℕ.1 }
def ℕ.3: ℕ { ℕ.suc ℕ.2 }

def ℕ.pred: ℕ → ℕ
{
	ℕ.elim
		([_: ℕ] ℕ)
		ℕ.0
		([x' _: ℕ] x')
}

def ℕ.+(x: ℕ, y: ℕ): ℕ
{
	ℕ.elim
		([_: ℕ] ℕ)
		x
		([y': ℕ, y'_rec: ℕ] ℕ.suc y'_rec)
		y
}

def ℕ.=0: ℕ → Type
{
	ℕ.elim ([_: ℕ] Type) Unit ([_: ℕ, _: Type] False)
}

def ℕ.0≠1(0=1: = ℕ ℕ.0 ℕ.1): False
{
	=.transport ℕ ℕ.=0 ℕ.0 ℕ.1 0=1 Unit.0
}

def ℕ.2≠3(2=3: = ℕ ℕ.2 ℕ.3): False
{
	ℕ.0≠1 (=.cong ℕ ℕ ([x: ℕ] ℕ.pred (ℕ.pred x)) ℕ.2 ℕ.3 2=3)
}

def ℕ.1+1≠3(1+1=3: = ℕ (ℕ.+ ℕ.1 ℕ.1) ℕ.3): False
{
	ℕ.2≠3 1+1=3
}
