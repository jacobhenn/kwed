// Dependent product of a base type and a family over the base
struct Product(A: Type, B: A → Type): Type {
    first: A,
    second: B first,
}

// Non-dependent Cartesian product of two types
def Pair(A B: Type): Type {
    Product A ([-: A] B)
}

def Pair.make(A B: Type, a: A, b: B): Pair A B {
    Product.make A ([-: A] B) a b
}

def Pair.uncurry(A B C: Type, f: (a: A, b: B) → C, pair: Pair A B): C {
    match pair to [-] C {
        pair a b => f a b,
    } 
}

def Pair.first(A B: Type, ): (Pair A B) → A {
    Product.first A ([-: A] B)
}

def Pair.second(A B: Type, ): (Pair A B) → B {
    Product.second A ([-: A] B)
}

def Pair.is-doubleton(A: Type, pair: Pair A A): Prop {
    Eq A (Pair.first pair) (Pair.second pair)
}

def Pair.doubleton(A: Type, a: A): Pair A A {
    Pair.make a a
}

def Pair.doubleton.is-injective(A: Type): IsInjective A (Pair A A) (Pair.doubleton A) {
    
}
